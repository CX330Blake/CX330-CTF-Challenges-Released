const std = @import("std");

pub fn getFlag(buf: []u8) void {
    const encrypted = [_]u8{ 0x54, 0x44, 0x4e, 0x54, 0x53, 0x7c, 0x4d, 0x72, 0x74, 0x30, 0x58, 0x33, 0x58, 0x32, 0x6e, 0x6a, 0x77, 0x36, 0x34, 0x58, 0x41, 0x36, 0x33, 0x3e, 0x58, 0x64, 0x6f, 0x34, 0x64, 0x6c, 0x34, 0x75, 0x58, 0x32, 0x6f, 0x37, 0x72, 0x6b, 0x63, 0x58, 0x65, 0x34, 0x58, 0x33, 0x58, 0x77, 0x6e, 0x34, 0x64, 0x62, 0x58, 0x37, 0x61, 0x58, 0x64, 0x33, 0x6c, 0x34, 0x26, 0x7a };

    const key: u8 = 0x7;

    for (encrypted, 0..) |e, i| {
        buf[i] = e ^ key;
    }
    buf[encrypted.len] = 0; // null terminator
}

pub fn main() !void {
    var stdin = std.io.getStdIn().reader();
    var stdout = std.io.getStdOut().writer();

    var input_buf: [64]u8 = undefined;
    var flag_buf: [64]u8 = undefined;

    getFlag(&flag_buf);

    try stdout.print("Enter flag: ", .{});
    const input = try stdin.readUntilDelimiterOrEof(&input_buf, '\n');

    if (std.mem.eql(u8, input.?, std.mem.sliceTo(&flag_buf, 0))) {
        try stdout.print("Correct!\n", .{});
    } else try stdout.print("Wrong!\n", .{});
}
